\mychapter{4}{Implementation}
\label{chapter:implemntation}

This chapter details the practical development and testing of the system. It focuses on the integration of various hardware and software components, the novel modifications made to existing projects, and the challenges encountered along the way. The discussion covers the connection setup between the Wii Remote and Raspberry Pi, the streaming of audiovisual data, the extension of Wii Remote emulation, and the creation of a Python-based input relay.

\section{Establishing Wii Remote Connectivity}

One of the initial challenges was to reliably connect the Wii Remote to the Raspberry Pis. This was achieved by enabling the Linux driver for the Wii Remote using:

\begin{lstlisting}[language=bash]
modprobe hid-wiimote
\end{lstlisting}

To ensure that this driver is loaded automatically at boot, the following command was run to add the wiimote drivers to the modules-load configuration:

\begin{lstlisting}[language=bash]
echo hid-wiimote | sudo tee /etc/modules-load.d/wiimote.conf
\end{lstlisting}

This step was crucial for providing a persistent connection between the Wii Remote and the Raspberry Pi environment.

\section{Selection of Wii Remote Libraries and Addressing Bluetooth Issues}

After evaluating multiple libraries and tools for Wii Remote interfacing, the xwiimote\cite{xwiimote} library was chosen, particularly for its Python bindings\cite{xwiimote_bindings}, which allowed for seamless integration into a Python script. During testing, an issue arose where the Wii Remote connected via Bluetooth but exhibited continuously flashing lights, with xwiimote failing to register inputs. Luckily this is a known issue\cite{xwiimote_issue} and could be resolved by modifying the Bluetooth configuration file at \texttt{/etc/bluetooth/input.conf} and adding the following line:

\begin{lstlisting}[language=bash]
ClassicBondedOnly=false
\end{lstlisting}

This adjustment enabled proper pairing and stable operation of the Wii Remote.

\section{Audio and Video Streaming Optimisation}
Streaming audio and video from the host Raspberry Pi to the client Pi posed a significant challenge, with a trade-off observed between media quality and latency. Higher quality streams resulted in high latency, while lower quality streams compromised user experience. The solution was to adopt the Real-time Transport Protocol (RTP) with carefully tuned broadcast and playback settings. Although further optimisations remain possible, this configuration currently offers a balanced compromise between low latency and acceptable media quality.

%% TODO: Add the contents of the play-rtp.sh and broadcast-rtp.sh scripts here

\section{Wii Remote Emulation Enhancements}

A core component of the project is the emulation of the Wii Remote on the host Raspberry Pi. This was implemented by adapting a modified version of the \texttt{WiimoteEmulator} originally developed by rnconrad\cite{wiimote_emulator}.

A fork by JRogaishio\cite{jr_wiimote_emu} was selected for its support for IP-based command reception—a critical requirement for network-based control.

My version\cite{kf_wiimote_emu} further extends this fork by adding support for transmitting IR and accelerometer data over an IP socket interface.

Key challenges in this area included:
\begin{itemize}

	% TODO: Change the wording of this
	\item \textbf{Mathematical Calibration:} In the \texttt{motion.c} file, significant effort was devoted to understanding and re-calibrating the accelerometer and IR data transformations. This process ensured that the emulated signals closely mimic the physical behaviour of the Wii Remote.

	      % Expand on this part
	\item \textbf{Software Integration:} Extensive modifications were required in \texttt{input.c} and \texttt{input\_socket.c} to integrate the new data types and to manage robust network communication. Despite these advances, some latency issues persist, and the IR emulation is currently limited to the lower half of the screen. Additionally, tuning the accelerometer may require further adjustments depending on the game (e.g., specific nuances observed in Mario Kart).

\end{itemize}

% TODO: Expand
\section{Python Script for Input Relay}
The final major component is a custom Python script that serves as a bridge between real Wii Remote inputs and the emulation layer on the host Raspberry Pi. Utilising the xwiimote Python bindings, the script captures the physical inputs, processes them, and transmits the data to the Wii Remote Emulator. This relay system was designed with robust error handling to manage intermittent connectivity issues, ensuring that inputs are reliably forwarded in real time.

\section{Automation of Device Setup}

To streamline the deployment process, a device setup script was developed. This script requires administrative privileges (sudo) and automates several critical configuration tasks, including:

\begin{itemize}

	\item Loading necessary kernel modules.
	\item Editing system files (such as /etc/bluetooth/input.conf) to adjust Bluetooth settings.
	\item Configuring environment variables and export paths for library dependencies.
\end{itemize}

By automating these tasks, the setup script minimises manual configuration errors and ensures a consistent environment across multiple devices.

\section{Testing and Validation}
Rigorous testing was conducted to evaluate the performance and reliability of the system

\subsubsection{Connectivity Tests}
Confirmed that the Wii Remote establishes a stable connection with the Raspberry Pis under various conditions.

\subsubsection{Latency and Quality Measurements}
Evaluated the balance between media quality and streaming latency, with iterative tuning of RTP settings.

\subsubsection{End-to-End Gameplay Trials}
Real-world testing using games such as Mario Kart provided insights into the system’s responsiveness and highlighted areas for future refinement, particularly regarding latency and IR display limitations.

% First challenge was getting the wii remote to connect to the raspberry pis. Required enabling the wii remote Linux drivers using 'modprobe hid-wiimote'. To ensure this always gets loaded at boot time, add it to the modules-load.d configuration: 'echo hid-wiimote | sudo tee /etc/modules-load.d/wiimote.conf'.
%
% Many different wiimote libraries and tools. Decided to use xwiimote (reference) and more specifically used xwiimote python bindings (reference) to create a python script
%
% Ran into issue where remote would connect through bluetooth but lights would keep flashing and xwiimote could not detect it. Have to edit '/etc/bluetooth/input.conf' and add the line 'ClassicBondedOnly=false'. (reference https://github.com/xwiimote/xwiimote/issues/109)
%
% Another challenge was streaming the audio and video from the host pi to the client pi. Main issue was either quality or latency. Higher quality was causing very high latency and vice versa. Solved by using rtp protocol with some very specific setting (show broadcast and play commands here??)
%
% Another part of the project was doing the wii remote emulation from the host pi to the wii. Used a modified version of Wiimote emulator by rnconrad (reference). Specifically modified JRogaishio's fork (reference) of the project whose changes have yet to merged to the original project. Used this fork as it fixes the ip version of the project which allows for receiving commands over a network which is what I want. Also adds some more documentation and fixes a compilation error. My version (reference) adds support for IR and accelerometer data over the ip socket interface. Many challenges here. Mainly figuring out all the accelerometer and IR maths in motion.c as well as adding all the plumbing in input.c and input_socket.c.
%
% Also latency issues which have not been resolved. Also issue with IR not going above bottom half of the screen. Potential issue of the tuning of accelerometer will be mario kart specific

% Last hard part was creating the python script that takes all the real wiimote inputs and translates then sends them to the wiimote emulator on the host pi.
%
% Maybe creating a device setup script that requires sudo and does all the changing of system files, drivers, Export paths for libs, etc
