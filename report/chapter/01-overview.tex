\mychapter{1}{Overview}
\label{chapter:overview}

The aim of this practical was to implement part of a compiler/translator for a small
expression language, by converting to increasingly simple intermediate representations, then finally
generating code in a target language (in this case, Java). There are three main steps to this process:
\begin{enumerate}
	\item Defunctionalise the program, so that all function calls are defined top
	      level functions, with the correct number of arguments.
	\item Convert the defunctionalised program to ANF, so that the operands to all
	      function calls, operators, and scrutinees of case and if expressions are
	      variable names.
	\item Generate Java code from the ANF. There should be one method for each
	      function in the ANF (which will be the original functions, plus the APPLY
	      function generated by defunctionalisation), and a main method which
	      evaluates the main expression.
\end{enumerate}

I have implemented the above steps in Haskell, in the \texttt{ANF.hs} file,
which takes a \texttt{Defun} program, defunctionalises it, converts it to ANF, and generates
executable Java code. In addition to this I have made my solution modular to
both help with readability and to ensure that additional language features are
handled with minimal or no changes to the existing code. I also decided to go
beyond the practical specification and implement a test suite to ensure the
correctness of my implementation to a greater extent than the provided test
cases. This fulfills both the basic and extended requirements of the
specification and beyond.

\begin{center}
	\noindent\rule{8cm}{0.4pt}
\end{center}



