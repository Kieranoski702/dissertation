\mychapter{5}{Implementation}
\label{chapter:implemntation}

This chapter details the practical development and testing of the system. It focuses on the integration of various hardware and software components, the novel modifications made to existing projects, and the challenges encountered along the way. The discussion covers the connection setup between the Wii Remote and Raspberry Pi, the streaming of audiovisual data, the extension of Wii Remote emulation, and the creation of a Python-based input relay.

\section{Establishing Wii Remote Connectivity}

One of the initial challenges was to reliably connect the Wii Remote to the Raspberry Pis. This was achieved by enabling the Linux driver for the Wii Remote using:

\begin{lstlisting}[language=bash]
modprobe hid-wiimote
\end{lstlisting}

To ensure that this driver is loaded automatically at boot, the following command was run to add the wiimote drivers to the modules-load configuration:

\begin{lstlisting}[language=bash]
echo hid-wiimote | sudo tee /etc/modules-load.d/wiimote.conf
\end{lstlisting}

This step was crucial for providing a persistent connection between the Wii Remote and the Raspberry Pi environment.

\section{Selection of Wii Remote Libraries and Addressing Bluetooth Issues}

After evaluating multiple libraries and tools for Wii Remote interfacing, the xwiimote\cite{xwiimote} library was chosen, particularly for its Python bindings\cite{xwiimote_bindings}, which allowed for seamless integration into a Python script. During testing, an issue arose where the Wii Remote connected via Bluetooth but exhibited continuously flashing lights, with xwiimote failing to register inputs. Luckily this is a known issue\cite{xwiimote_issue} and could be resolved by modifying the Bluetooth configuration file at \texttt{/etc/bluetooth/input.conf} and adding the following line:

\begin{lstlisting}[language=bash]
ClassicBondedOnly=false
\end{lstlisting}

This adjustment enabled proper pairing and stable operation of the Wii Remote.

\section{Audio and Video Streaming Optimisation}
Streaming audio and video from the host Raspberry Pi to the client Pi posed a significant challenge, with a trade-off observed between media quality and latency. Higher quality streams resulted in high latency, while lower quality streams compromised user experience. The solution was to adopt the Real-time Transport Protocol (RTP) with carefully tuned broadcast and playback settings. Although further optimisations remain possible, this configuration currently offers a balanced compromise between low latency and acceptable media quality.

%% TODO: Add the contents of the play-rtp.sh and broadcast-rtp.sh scripts here

\section{Wii Remote Emulation Enhancements}

A core component of the project is the emulation of the Wii Remote on the host Raspberry Pi. This was implemented by adapting a modified version of the \texttt{WiimoteEmulator} originally developed by Ryan Conrad\cite{wiimote_emulator} (known as rnconrad on GitHub). \texttt{WiimoteEmulator} is able to emulate a bluetooth wii controller in software, allowing the wii to be controlled by many different input devices such as a keyboard, mouse, or text commands over a network.

A fork of the project by JRogaishio\cite{jr_wiimote_emu} was selected as it fixes two critical bugs. The first
bug is that the ip command in the original project was not working due to an index error. The second bug is that the original project was not compiling due to a call to \texttt{graceful\_disconnect()} which was not defined.

The researcher's version\cite{kf_wiimote_emu} further extends this fork by adding support for transmitting IR and accelerometer data over the IP socket interface.

\subsection*{Enhancements and Challenges}


\subsubsection*{IR Emulation}

IR emulation in the system is responsible for generating the infrared (IR) sensor data that the Wii Remote expects when pointing at a sensor bar. The implementation leverages the functions defined in \texttt{motion.c}. First, the function \texttt{look\_at\_pointer} computes a transformation matrix based on normalized pointer coordinates (\texttt{pointer\_x} and \texttt{pointer\_y}). This matrix defines the orientation of the emulated Wii Remote relative to a virtual screen, where physical dimensions (e.g., screen width, sensor bar width) and viewing distance are factored in.

Next, \texttt{set\_motion\_state} uses this transformation to compute two sensor points (\texttt{sensor\_pt0} and \texttt{sensor\_pt1}). These points are projected into a normalized coordinate system via a custom perspective projection matrix (generated by \texttt{make\_cam\_projection\_mat}). Once the homogeneous coordinates are normalized, the resulting positions are mapped to the resolution expected by the Wii Remote (typically a range of 0-1023 in x and 0-767 in y). The size of each IR object is also computed based on the depth component (\texttt{z}) of the projected points, simulating the apparent size changes of IR sources with distance. This process ensures that the emulated IR data closely mimics the signals generated by a physical sensor bar.

\subsubsection*{Accelerometer Emulation}

%% This function isn't really used by my addition so maybe remove/reword this section

Accelerometer emulation is handled primarily in the function \texttt{set\_accelerometer} in \texttt{motion.c}. The goal is to simulate the Wii Remote's accelerometer readings based on its orientation. A fixed gravity vector (set as \texttt{\{0, -1.0, 0\}}) represents the effect of gravity on the remote. This vector is then transformed by the inverse-transposed 3x3 submatrix extracted from the Wii Remote's orientation matrix (computed in \texttt{look\_at\_pointer}).

The transformed acceleration values are clamped to a plausible range (between -3.4 and 3.4) to prevent unrealistic sensor readings. Finally, these values are scaled and shifted using the constants \texttt{accelerometer\_zero} and \texttt{accelerometer\_unit} to match the raw data format that the Wii Remote firmware expects. Although the accelerometer emulation code in \texttt{set\_accelerometer} is currently commented out in some testing scenarios (with real input values handled in \texttt{input.c}), it provides a framework for generating synthetic accelerometer data based on the current pointer orientation. Fine-tuning of these calculations is ongoing, especially to ensure compatibility with specific game dynamics (e.g., the sensitivity required by Mario Kart).

\subsubsection*{Latency}

Latency is a critical performance metric for both the audiovisual streaming and the emulation of controller inputs. Several design decisions were made to minimise latency across the system:

\begin{itemize}
	\item \textbf{Non-blocking I/O:} In the \texttt{input\_socket.c} file, UDP sockets are configured with the \texttt{SOCK\_NONBLOCK} flag to ensure that the system can continuously poll for new input events without stalling on network reads. This approach is essential for maintaining responsiveness.

	\item \textbf{Optimised Data Pipelines:} The system uses lightweight binary protocols for both IR and accelerometer updates. By sending fixed-length packets (e.g., 13-byte packets for IR and accelerometer data), the overhead associated with parsing and error checking is reduced. These binary packets are handled in \texttt{input\_socket.c}, where functions such as \texttt{ntohf} convert network-order floats to host-order values with minimal delay.

%% TODO: Add fix to altency issue here

\end{itemize}

Despite these efforts, some latency issues remain due to the inherent latency present in the \texttt{WiimoteEmulator}. Further work on the \texttt{WiimoteEmulator} project is needed to address these challenges and improve the overall responsiveness of the system.

\section{Python Script for Input Relay}
The system’s final major component is a custom Python script (\texttt{wiimote\_to\_emulator.py}) that serves as a bridge between the physical Wii Remote and the emulation backend running on the host Raspberry Pi. This script leverages the \texttt{xwiimote} Python bindings to interface directly with the Wii Remote hardware, continuously monitoring for various input events and relaying them to the Wii Remote Emulator via UDP.

Key features and design details include:

\subsection*{Wiimote Connection and Monitoring:}
The script initialises a \texttt{xwiimote} monitor to detect when a Wii Remote is connected. Once a device is found, it creates an interface with the device and opens it for both reading and writing. This setup is essential to capture both analog events (e.g., accelerometer and IR data) and digital button presses.

\subsection*{Non-Blocking I/O and Event Polling:}
Using the \texttt{select.poll()} mechanism, the script sets up non-blocking I/O on the Wii Remote’s file descriptor. This allows the script to efficiently wait for input events without stalling the main event loop. When events are detected, the script calls \texttt{dev.dispatch(evt)} to process them.

\subsection*{Event Processing and Binary Packet Formation:}
Depending on the event type, the script processes the data accordingly:
\subsubsection*{Accelerometer Events}
When an accelerometer event is received (identified by \texttt{xwiimote.EVENT\_ACCEL}), the script retrieves the raw accelerometer values from channel 0. It then normalizes these values (using a custom scaling and offset transformation) and packs them into a binary packet with the header \texttt{0x02}. The binary format is:
\begin{center}
	\texttt{[1 byte event type (0x02)] + [4 bytes float ax] +}
	\texttt{[4 bytes float ay] + [4 bytes float az]}
\end{center}
\subsubsection*{IR Events:}
For IR events (identified by \texttt{xwiimote.EVENT\_IR}), the script retrieves the IR coordinates and normalizes them to a [0,1] range. It then packs the data into a binary packet with header \texttt{0x01}:
\begin{center}
	\texttt{[1 byte event type (0x01)] + [4 bytes float x] +}
	\texttt{[4 bytes float y] + [4 bytes float z]}
\end{center}
\subsubsection*{Button (Key) Events:}
The script also processes key events (e.g., pressing the \texttt{+}, \texttt{-}, \texttt{HOME}, \texttt{A}, and \texttt{B} buttons). These are handled by sending text-based command packets (e.g., \texttt{"button 1 WIIMOTE\_PLUS"}) over UDP to indicate button press and release actions.

\subsection*{UDP Communication:}
A UDP socket is created to transmit the binary (and text-based) update packets to the Wii Remote Emulator. The target emulator’s IP address and port are provided via command-line arguments. The script logs key actions and any errors using Python’s built-in logging facilities, ensuring that debugging information is available during operation.

\subsection*{Robust Error Handling:}
Throughout the script, exceptions (such as I/O errors during event dispatching) are caught and logged. This approach ensures that transient errors do not break the event loop, thereby maintaining reliable real-time transmission of control data.

\section{Automation of Device Setup}

To streamline the deployment process, a device setup script (\texttt{setup.sh}) was developed. This script requires administrative privileges (sudo) and automates several critical configuration tasks, including:

\begin{itemize}

	\item Loading necessary kernel modules.
	\item Editing system files (such as /etc/bluetooth/input.conf) to adjust Bluetooth settings.
	\item Configuring environment variables and export paths for library dependencies.
    \item Installing \texttt{xwiimote} and its Python bindings.
    \item Downloading and compiling the custom Wii Remote Emulator.
\end{itemize}

By automating these tasks, the setup script minimises manual configuration errors and ensures a consistent environment across multiple devices.

%% \section{Testing and Validation}
%% Rigorous testing was conducted to evaluate the performance and reliability of the system

%% \subsubsection*{Connectivity Tests}
%% Confirmed that the Wii Remote establishes a stable connection with the Raspberry Pis under various conditions.

%% \subsubsection*{Latency and Quality Measurements}
%% Evaluated the balance between media quality and streaming latency, with iterative tuning of RTP settings.

%% \subsubsection*{End-to-End Gameplay Trials}
%% Real-world testing using games such as Mario Kart provided insights into the system’s responsiveness and highlighted areas for future refinement, particularly regarding latency and IR display limitations.







% First challenge was getting the wii remote to connect to the raspberry pis. Required enabling the wii remote Linux drivers using 'modprobe hid-wiimote'. To ensure this always gets loaded at boot time, add it to the modules-load.d configuration: 'echo hid-wiimote | sudo tee /etc/modules-load.d/wiimote.conf'.
%
% Many different wiimote libraries and tools. Decided to use xwiimote (reference) and more specifically used xwiimote python bindings (reference) to create a python script
%
% Ran into issue where remote would connect through bluetooth but lights would keep flashing and xwiimote could not detect it. Have to edit '/etc/bluetooth/input.conf' and add the line 'ClassicBondedOnly=false'. (reference https://github.com/xwiimote/xwiimote/issues/109)
%
% Another challenge was streaming the audio and video from the host pi to the client pi. Main issue was either quality or latency. Higher quality was causing very high latency and vice versa. Solved by using rtp protocol with some very specific setting (show broadcast and play commands here??)
%
% Another part of the project was doing the wii remote emulation from the host pi to the wii. Used a modified version of Wiimote emulator by rnconrad (reference). Specifically modified JRogaishio's fork (reference) of the project whose changes have yet to merged to the original project. Used this fork as it fixes the ip version of the project which allows for receiving commands over a network which is what I want. Also adds some more documentation and fixes a compilation error. My version (reference) adds support for IR and accelerometer data over the ip socket interface. Many challenges here. Mainly figuring out all the accelerometer and IR maths in motion.c as well as adding all the plumbing in input.c and input_socket.c.
%
% Also latency issues which have not been resolved. Also issue with IR not going above bottom half of the screen. Potential issue of the tuning of accelerometer will be mario kart specific

% Last hard part was creating the python script that takes all the real wiimote inputs and translates then sends them to the wiimote emulator on the host pi.
%
% Maybe creating a device setup script that requires sudo and does all the changing of system files, drivers, Export paths for libs, etc
