\chapter{Software Engineering Process}
\label{chapter:sep}


Development followed the waterfall methodology\cite{royce1987managing}. This structured, sequential model fit the constraints of a fixed deadline and a single-developer workflow. Unlike Agile or iterative models\cite{atlassian2025agile}, which encourage continuous delivery and rapid prototyping, the waterfall approach provided distinct stages, enabling full completion and documentation of each phase before moving forward.

\section{Software Development Approach}

The waterfall model supported the project in two key ways:
\begin{enumerate}
	\item \textbf{Fixed Deadline:} A single, non-negotiable deadline for delivering the complete system demanded a structured approach, and the sequential nature of the waterfall model addressed all project requirements methodically. Each phase built upon the previous one, enabling a well-planned progression from concept to final implementation.

	\item \textbf{Single Developer Environment:} The lack of team coordination requirements made the overhead of Agile methods, such as complex coordination and iterative refinement, unnecessary. Instead, linear development -- where requirements, design, implementation, and testing followed in sequence -- offered clarity and focus, streamlining the process.

\end{enumerate}

The process began with a detailed requirements specification, outlining goals and objectives for the system. The design phase followed, defining system architecture and planning integration points across subsystems.

\section{Tools and Technologies}

\subsection{Programming Languages}

The project uses a combination of C, Python, and Bash to target system-level performance, ease of integration, and automation.

\subsubsection{C}
Chosen for low-level hardware interaction and performance-critical components. The existing \texttt{WiimoteEmulator}, originally implemented in C, required extended functionality -- best achieved by maintaining the same language to ensure compatibility, reduce overhead, and optimise latency. Consideration went to alternatives such as C++ or Rust; however, C++ introduced unnecessary abstraction for a project of this scope, and Rust's stricter compile-time checks and learning curve made it less suitable within the project's time constraints.

\subsubsection{Python}
Used for the input relay system. Python enabled rapid development of code to handle Bluetooth connectivity, input detection, and communication with the host machine. Its extensive libraries and readability made it ideal for writing higher-level control scripts. Languages like Java or Node.js fell out of consideration due to limited library support and less straightforward integration with low-level system components.

\subsubsection{Bash}
Utilised for system configuration and environment setup. A Bash script automates the configuration of the development environment, installation of dependencies, and compilation of the C codebase. This allowed reproducible builds and simplified development environment setup. While Python could also perform these tasks, Bash offered a more concise and native approach for shell-level automation.

\subsection{Build and Deployment Tools}
Version control through Git supported code integrity, traceability, and collaboration-readiness, even in a single-developer context. Tracking each change allowed for reliable rollback, documentation of evolution, and structured branching for experimental features. Git also ensured compatibility with deployment tools and safeguarded against data loss across environments. The ability to manage different stages of development through commits and tags proved essential for both incremental testing and final delivery.
