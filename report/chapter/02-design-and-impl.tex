\mychapter{2}{Design and Implementation}
\label{chapter:design-and-impl}

The implementation of this practical was structured into three distinct phases: defunctionalisation, conversion to Administrative Normal Form (ANF), and Java code generation. Each phase required specific design decisions to ensure correctness, maintainability, and seamless transition between the intermediate representations. This section delves into the key design considerations, challenges, and solutions implemented during the project.


\section{Defunctionalisation}
Defunctionalisation was the first phase of the transformation pipeline. The primary challenge in this phase was ensuring that all function calls were converted to top-level functions with the exact number of arguments. This required handling three distinct scenarios: perfectly applied functions, partially applied functions, and over-applied functions.

For partial application, a key design decision was to introduce constructor tags to represent the intermediate state of a function application. For example, a function \texttt{f(x, y, z)} partially applied with arguments \texttt{x} and \texttt{y} would be represented by a constructor\\ \texttt{f\_2(x, y)}. These tags serve as a compact and systematic way to track the number of arguments already applied, allowing the program to distinguish between different states of application. This approach simplified the transformation logic while maintaining the flexibility to handle arbitrarily complex applications.

Over-application presented an additional complexity, as it required splitting the excess arguments into successive calls to a special \texttt{APPLY} function. The design of \texttt{APPLY} was particularly interesting. It dynamically evaluated the remaining arguments and either completed the function application or returned a new partially applied function. By introducing this mechanism, the implementation achieved a balance between correctness and extensibility, ensuring that even cases with excessive arguments were handled gracefully.

The defunctionalisation process also needed to analyze the arity of all functions in the program. This was implemented using a helper function that mapped function names to their respective argument counts. This mapping ensured that all transformations respected the expected input structure of each function.

\section{Conversion to ANF}
Administrative Normal Form (ANF) requires that every operand in a function
call, binary operation, or conditional be a variable. The conversion to ANF
involved restructuring each expression into a series of let-bindings, where
intermediate results were assigned to fresh variables.

A significant design decision here was the mechanism for generating unique variable names. A helper function, \texttt{fresh}, was implemented to produce unique variable names by appending numeric suffixes to a base name. This ensured that variable names did not collide, even in deeply nested or recursive expressions. By using this systematic naming approach, the implementation avoided bugs related to scope and variable shadowing.

Handling case expressions in ANF posed another interesting challenge. Each constructor alternative in a case expression required extracting its arguments into distinct variables. To achieve this, the transformation introduced local bindings for constructor arguments, ensuring they were accessible in the body of each alternative. This not only preserved the semantics of the original expression but also simplified the subsequent translation to Java code.

Binary operations and conditionals were similarly transformed into ANF by isolating their operands. For instance, an expression like \texttt{x + y} was split into two let-bindings for the values of \texttt{x} and \texttt{y}, followed by a third let-binding for their sum. This systematic decomposition ensured that all expressions adhered to the strict variable-centric structure required by ANF.
\section{Java Code Generation}
The final phase involved translating the ANF representation into executable Java code. A major design decision here was to represent all values uniformly using Java's \texttt{Object} type. While this introduced some type-checking overhead, it provided the flexibility to handle both primitive values (like integers) and complex data structures (like constructors).

Constructors in the source language were mapped to a custom Java class, \texttt{Constructor}, with fields for a tag (representing the constructor name) and an array of arguments. This design allowed case expressions to be translated into Java \texttt{switch} statements, where the constructor tag served as the discriminant. The arguments of each constructor were extracted into local variables, ensuring they could be used in the body of the corresponding case alternative.

A particularly noteworthy decision was how to handle nested expressions during Java code generation. To preserve the semantics of the ANF representation, each expression was translated recursively, with intermediate results stored in local variables or anonymous inner classes. For example, let-bindings in ANF were mapped to anonymous inner classes in Java, encapsulating the binding and ensuring proper scoping of variables. This approach, while unconventional, allowed for a direct and faithful translation of ANF to Java.

Function calls in Java were another area of interest. Top-level functions were translated into static Java methods, while the \texttt{APPLY} function was implemented as a generic method capable of handling partial application. The use of static methods ensured efficient function invocation while maintaining the modularity of the generated code.

\section{Challenges and Solutions}
One of the most intriguing challenges arose in the interaction between defunctionalisation and ANF conversion. Specifically, partially applied functions needed to be represented as constructor tags during defunctionalisation, but their ANF transformation required careful handling to avoid losing their state. This was resolved by ensuring that constructor tags introduced during defunctionalisation were treated as first-class values during ANF conversion.

Another challenge was the translation of nested function calls. For example, an expression like \texttt{f(g(x))} required transforming \texttt{g(x)} into a let-binding, followed by passing the resulting variable as an argument to \texttt{f}. This nested restructuring was implemented recursively, with each layer of the call stack generating new bindings for intermediate results. The recursive approach not only maintained the integrity of the original expression but also ensured that the generated Java code remained readable and efficient.

Lastly, the design of the \texttt{APPLY} function was a highlight of the project. Its ability to dynamically handle varying argument counts, combined with the use of constructor tags for partially applied functions, demonstrated the power of intermediate representations. This design ensured that the system could gracefully handle edge cases, such as over-application or nested partial applications, without requiring ad hoc solutions.

